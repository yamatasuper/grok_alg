Теория

LOG N, O 
Конечно, я могу рассказать про \(\log p\) и \(O\) большое.

1. **Десятичный логарифм (\(\log p\))**:

   Десятичный логарифм числа \(p\), обозначаемый как \(\log p\), это степень, в которую нужно возвести число 10, чтобы получить \(p\). Формально это записывается как:

   \[\log p = x \quad \text{так что} \quad 10^x = p\]

   Например, если \(\log 100 = 2\), это означает, что \(10^2 = 100\), потому что 100 - это \(10\) возводимое в квадрат. Десятичный логарифм широко используется в различных областях, таких как наука, инженерия, экономика и другие, особенно для работы с большими числами и диапазонами значений.

2. **\(O\) большое (Big O)**:

   \(O\) большое - это обозначение в теории алгоритмов, используемое для описания асимптотической сложности алгоритма или функции. Оно указывает на верхнюю границу роста алгоритма в терминах его временной или пространственной сложности при стремлении размера входных данных к бесконечности.

   Например, если говорят, что сложность алгоритма равна \(O(n^2)\), это означает, что время выполнения алгоритма ограничено квадратичной функцией от размера входных данных \(n\). То есть, время выполнения алгоритма будет расти пропорционально квадрату размера входных данных.

   \(O\) большое часто используется для анализа эффективности алгоритмов и помогает разработчикам понять, как алгоритм будет вести себя при увеличении размера данных. Это позволяет выбирать наиболее подходящие алгоритмы для конкретных задач. 
O(log п), или логарифмическое время. Пример: бинарный поиск. О(п), или линейное время. Пример: простой поиск.
О(п * log п). Пример: эффективные алгоритмы сортировки (быстрая сортировка - но об этом в главе 4).
О(п2 ). Пример: медленные алгоритмы сортировки (сортировка выбо­ ром - см. главу 2).
О(п/). Пример: очень медленные алгоритмы (задача о коммивояжере - о ней будет рассказано в следующем разделе).

Для положительных целых чисел n факториал ! n! определён как произведение всех целых чисел от 1 до 
n. Например, 5!=5×4×3×2×1=120
5!=5×4×3×2×1=120.

БИНАРНЫЙ ПОИСК

Конечно, вот краткое сравнение простого (линейного) поиска и бинарного поиска:

1. **Простой (линейный) поиск**:
   - Поиск элемента производится последовательно от начала массива до его конца.
   - Время выполнения пропорционально размеру массива \(O(n)\), где \(n\) - количество элементов в массиве.
   - Применим для любого массива данных, не требует предварительной сортировки.
   - Неэффективен для больших массивов данных, так как время поиска растёт линейно с увеличением размера массива.

2. **Бинарный поиск**:
   - Предполагает, что массив отсортирован по возрастанию или убыванию.
   - Работает путём разделения массива пополам и последующего сужения области поиска.
   - Время выполнения логарифмическое \(O(\log n)\), где \(n\) - количество элементов в массиве.
   - Эффективен для больших отсортированных массивов, так как время поиска растёт логарифмически с увеличением размера массива.

Таким образом, основное отличие между простым и бинарным поиском заключается в способе организации поиска и его временной сложности. Бинарный поиск позволяет эффективно находить элемент в отсортированном массиве, в то время как простой поиск подходит для неотсортированных данных или небольших массивов.

Шпаргалка
c:i Бинарный поиск работает намного быстрее простого.
1:1 Время выполнения O(log п) быстрее О(п), а с увеличением размера спи­ ска, в котором ищется значение, оно становится намного быстрее.
1:1 Скорость алгоритмов не измеряется в секундах. 1:1 Время выполнения алгоритма описывается ростом количества операций. 1:1 Время выполнения алгоритмов выражается как «О-большое~.



Массивы и связанные списки Массив - это структура данных, представляющая собой упорядоченный набор элементов одного типа, доступ к которым осуществляется по индексу. Связанный список - это структура данных, где каждый элемент содержит ссылку на следующий элемент, образуя последовательность, что обеспечивает гибкость вставки и удаления элементов.  Какую структуру данных вы бы использовали для реализации этой оче­реди - массив или связанный список? (Подсказка: связанные списки хорошо подходят для вставки/удаления, а массивы - для произволь­ного доступа к элементам. Что из этого понадобится в данном случае?)
Ответ: Связанный список. Вставка происходит очень часто (офици­ анты добавляют заказы), а связанные списки эффективно выполняют эту операцию. Ни поиск, ни произвольный доступ (сильные стороны массивов) вам не понадобятся, потому что повар всегда извлекает из очереди первый заказ.
  Ответ: Поиск - медленнее, чем для массивов, и быстрее, чем для связанныхсписков.Вставка- быстрее,чемдлямассивов,истакойже скоростью для связанных списков.

Шпора Память компьютера напоминает огромный шкаф с ящиками.
Если вам потребуется сохранить набор элементов, воспользуйтесь мас­сивом или списком.
В массиве все элементы хранятся в памяти рядом друг с другом.
В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе хранится адрес следующего элемента.
Массивы обеспечивают быстрое чтение. Списки обеспечивают быструю вставку и выполнение.
Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т. д.).


СТЕК
Шпаргалка
* 		о  Когда функция вызывает саму себя, это  называется рекурсией. 
* 		о  В каждой рекурсивной функции должно  быть два случая: базовый и рекурсивный. о Стек поддерживает две операции: зане­  сение и извлечение элементов. 
о Все вызовы функций сохраняются в сте­ ке вызовов.
о Если стек вызовов станет очень большим, он займет слишком много памяти.

