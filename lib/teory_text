Теория

LOG N, O 
Конечно, я могу рассказать про \(\log p\) и \(O\) большое.

1. **Десятичный логарифм (\(\log p\))**:

   Десятичный логарифм числа \(p\), обозначаемый как \(\log p\), это степень, в которую нужно возвести число 10, чтобы получить \(p\). Формально это записывается как:

   \[\log p = x \quad \text{так что} \quad 10^x = p\]

   Например, если \(\log 100 = 2\), это означает, что \(10^2 = 100\), потому что 100 - это \(10\) возводимое в квадрат. Десятичный логарифм широко используется в различных областях, таких как наука, инженерия, экономика и другие, особенно для работы с большими числами и диапазонами значений.

2. **\(O\) большое (Big O)**:

   \(O\) большое - это обозначение в теории алгоритмов, используемое для описания асимптотической сложности алгоритма или функции. Оно указывает на верхнюю границу роста алгоритма в терминах его временной или пространственной сложности при стремлении размера входных данных к бесконечности.

   Например, если говорят, что сложность алгоритма равна \(O(n^2)\), это означает, что время выполнения алгоритма ограничено квадратичной функцией от размера входных данных \(n\). То есть, время выполнения алгоритма будет расти пропорционально квадрату размера входных данных.

   \(O\) большое часто используется для анализа эффективности алгоритмов и помогает разработчикам понять, как алгоритм будет вести себя при увеличении размера данных. Это позволяет выбирать наиболее подходящие алгоритмы для конкретных задач. 
O(log п), или логарифмическое время. Пример: бинарный поиск. О(п), или линейное время. Пример: простой поиск.
О(п * log п). Пример: эффективные алгоритмы сортировки (быстрая сортировка - но об этом в главе 4).
О(п2 ). Пример: медленные алгоритмы сортировки (сортировка выбо­ ром - см. главу 2).
О(п/). Пример: очень медленные алгоритмы (задача о коммивояжере - о ней будет рассказано в следующем разделе).

Для положительных целых чисел n факториал ! n! определён как произведение всех целых чисел от 1 до 
n. Например, 5!=5×4×3×2×1=120
5!=5×4×3×2×1=120.

БИНАРНЫЙ ПОИСК

Конечно, вот краткое сравнение простого (линейного) поиска и бинарного поиска:

1. **Простой (линейный) поиск**:
   - Поиск элемента производится последовательно от начала массива до его конца.
   - Время выполнения пропорционально размеру массива \(O(n)\), где \(n\) - количество элементов в массиве.
   - Применим для любого массива данных, не требует предварительной сортировки.
   - Неэффективен для больших массивов данных, так как время поиска растёт линейно с увеличением размера массива.

2. **Бинарный поиск**:
   - Предполагает, что массив отсортирован по возрастанию или убыванию.
   - Работает путём разделения массива пополам и последующего сужения области поиска.
   - Время выполнения логарифмическое \(O(\log n)\), где \(n\) - количество элементов в массиве.
   - Эффективен для больших отсортированных массивов, так как время поиска растёт логарифмически с увеличением размера массива.

Таким образом, основное отличие между простым и бинарным поиском заключается в способе организации поиска и его временной сложности. Бинарный поиск позволяет эффективно находить элемент в отсортированном массиве, в то время как простой поиск подходит для неотсортированных данных или небольших массивов.

Шпаргалка
c:i Бинарный поиск работает намного быстрее простого.
1:1 Время выполнения O(log п) быстрее О(п), а с увеличением размера спи­ ска, в котором ищется значение, оно становится намного быстрее.
1:1 Скорость алгоритмов не измеряется в секундах. 1:1 Время выполнения алгоритма описывается ростом количества операций. 1:1 Время выполнения алгоритмов выражается как «О-большое~.



Массивы и связанные списки Массив - это структура данных, представляющая собой упорядоченный набор элементов одного типа, доступ к которым осуществляется по индексу. Связанный список - это структура данных, где каждый элемент содержит ссылку на следующий элемент, образуя последовательность, что обеспечивает гибкость вставки и удаления элементов.  Какую структуру данных вы бы использовали для реализации этой оче­реди - массив или связанный список? (Подсказка: связанные списки хорошо подходят для вставки/удаления, а массивы - для произволь­ного доступа к элементам. Что из этого понадобится в данном случае?)
Ответ: Связанный список. Вставка происходит очень часто (офици­ анты добавляют заказы), а связанные списки эффективно выполняют эту операцию. Ни поиск, ни произвольный доступ (сильные стороны массивов) вам не понадобятся, потому что повар всегда извлекает из очереди первый заказ.
  Ответ: Поиск - медленнее, чем для массивов, и быстрее, чем для связанныхсписков.Вставка- быстрее,чемдлямассивов,истакойже скоростью для связанных списков.

Шпора Память компьютера напоминает огромный шкаф с ящиками.
Если вам потребуется сохранить набор элементов, воспользуйтесь мас­сивом или списком.
В массиве все элементы хранятся в памяти рядом друг с другом.
В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе хранится адрес следующего элемента.
Массивы обеспечивают быстрое чтение. Списки обеспечивают быструю вставку и выполнение.
Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т. д.).


СТЕК
Шпаргалка
* 		о  Когда функция вызывает саму себя, это  называется рекурсией. 
* 		о  В каждой рекурсивной функции должно  быть два случая: базовый и рекурсивный. о Стек поддерживает две операции: зане­  сение и извлечение элементов. 
о Все вызовы функций сохраняются в сте­ ке вызовов.
о Если стек вызовов станет очень большим, он займет слишком много памяти.

Шпаргалка
о Стратегия «разделяй и властвуй основана на разбиении задачи на уменьшающиеся фрагменты  если вы ичпользуете
стратегию «разделяй и вла­ ствуй» со списком, то базовым случаем, скорее всего, является пустой массив или массив из одного элемента .
о Если вы реализуете алгоритм быстрой сортировки, выберите в качестве опорного случайный элемент. Среднее время выполнения быстрой сор­тировки составляет О(п log п)!
о Константы в «О-большом» иногда могут иметь значение. Именно по этой причине быстрая сортировка быстрее сортировки слиянием.
о При сравнении простой сортировки с бинарной константа почти никогда роли не играет, потому что O(log п) слишком сильно превосходит О(п) по скорости при большом размере списка.

ХЭШИ

Хеши хорошо подходят для решения следующих задач:
i:i моделирование отношений между объектами;
i:i устранение дубликатов;
о кэширование/запоминание данных вместо выполнения работы на сер­ вере.


Q Хеш-таблица создается объединением хеш-функции с массивом.
Q Коллизии нежелательны. Хеш-функция должна свести количество кол­
лизий к минимуму.
Q Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки и удаления.
Q Хеш-таблицы хорошо подходят для моделирования отношений между объектами.
Q Как только коэффициент заполнения превышает 0,7 , пора изменять раз­ мер хеш-таблицы.
Q Хеш-таблицы используются для кэширования данных (например, на веб-серверах) .
Q Хеш-таблицы хорошо подходят для обнаружения дубликатов.

Графы

о Поиск в ширину позволяет определить, существует ли путь из А в В.
о Если путь существует, то поиск в ширину находит кратчайший путь.
о Если в вашей задаче требуется найти «кратчайшее Х», попробуйте смо­ делировать свою задачу графом и воспользуйтесь поиском в ширину для ее решения.
о В направленном графе есть стрелки, а отношения действуют в направле­ нии стрелки (Рама-+ Адит означает «Рама должен Адиту»).
о В ненаправленных графах стрелок нет, а отношение идет в обе сторон·ы (Росс - Рэйчел означает «Росс встречается с Рэйчел, а Рэйчел встреча­ ется с Россом».)
о Очереди относятся к категории FIFO («первым вошел, первым вышел»).
о Стек относится к категории LIFO («последним пришел, первым вышел»).
о Людей следует проверять в порядке их добавления в список поиска, поэтому список поиска должен быть оформлен в виде очереди, иначе найденный путь не будет кратчайшим.
о Позаботьтесь о том, чтобы уже прове­ ренный человек не проверялся заново, иначе может возникнуть бесконечный цикл .

Шпаргалка
l:J Поиск в ширину вычисляет кратчайший путь в невзвешенном графе.
l:J Алгоритм Дейкстры вычисляет кратчайший путь во взвешенном графе.
1:1 Алгоритм Дейкстры работает только в том случае, если все веса поло­ жительны.
1:J При наличии отрицательных весов используйте алгоритм Беллмана­ Форда.

Жадные алгоритмы 
стремятся к локальной оптимизации в расчете на то, что в итоге будет достигнут глобальный оптимум.
а У NР-полных задач не существует известных быстрых решений.
о Если у вас имеется NР-полная задача, лучше всего воспользоваться при­ ближенным алгоритмом.
о Жадные алгоритмы легко реализуются и быстро выполняются, поэтому из них получаются хорошие приближенные алгоритмы.